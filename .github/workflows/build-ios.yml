name: Webcrm test env:iOS IPA Build for App Store...

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Installer SVN
        run: |
          brew install subversion

      - name: Cloner le projet depuis SVN
        run: |
          echo "Téléchargement du code depuis SVN..."
          svn checkout --username "${{ secrets.SVN_USERNAME }}" --password "${{ secrets.SVN_PASSWORD }}" https://svn.jiscomputing.com/crmconnect_mobile/ project

      - name: Installer Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: 3.24.1
          architecture: x64

      - name: Installer les dépendances Flutter
        run: |
          cd project
          flutter pub get

      - name: Corriger la version minimale iOS
        run: |
          cd project/ios
          sed -i '' 's/platform :ios, '9.0'/platform :ios, '12.0'/' Podfile
          pod install --repo-update

      - name: Décrypter le certificat et le profil de provisioning
        run: |
          mkdir -p certificates
          
          # Méthode différente de décodage pour le certificat
          # Ajouter une ligne vide à la fin pour assurer un décodage complet
          echo "${{ secrets.IOS_CERTIFICATE_P12 }}" > cert_base64.txt
          cat cert_base64.txt | base64 -d > certificates/ios_cert.p12
          
          # Décodage normal pour le profil de provisioning
          echo "${{ secrets.IOS_PROVISIONING_PROFILE }}" | base64 --decode > certificates/profile.mobileprovision
          
          # Vérifier les fichiers
          ls -la certificates/
          echo "Taille du certificat P12: $(wc -c < certificates/ios_cert.p12) octets"
          echo "Taille du profil de provisioning: $(wc -c < certificates/profile.mobileprovision) octets"
          
          # Analyser le format du fichier P12
          file certificates/ios_cert.p12

      - name: Vérifier l intégrité du certificat
        run: |
          # Vérifier si le fichier est un certificat P12 valide
          file certificates/ios_cert.p12
          
          # Tester avec OpenSSL pour voir si le certificat est lisible
          openssl pkcs12 -info -in certificates/ios_cert.p12 -nokeys -passin pass:123456789 -nocerts || echo "⚠️ Impossible de lire le certificat avec le mot de passe"

      # Approche alternative pour l'import du certificat
      - name: Installer le certificat manuellement
        run: |
          # Créer un nouveau keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          security create-keychain -p "temp_password" "$KEYCHAIN_PATH"
          security unlock-keychain -p "temp_password" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          
          # Rendre le keychain actif et configurer pour ne pas demander de confirmation
          security list-keychains -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed 's/"//g')
          security default-keychain -s "$KEYCHAIN_PATH"
          
          # Tester l'accès au certificat avec différentes approches
          echo "Essai 1: Mot de passe sans échappement"
          openssl pkcs12 -in certificates/ios_cert.p12 -nocerts -nodes -passin pass:123456789 || echo "Échec essai 1"
          
          echo "Essai 2: Mot de passe avec guillemets simples"
          openssl pkcs12 -in certificates/ios_cert.p12 -nocerts -nodes -passin 'pass:123456789' || echo "Échec essai 2"
          
          echo "Essai 3: Mot de passe sur la ligne de commande"
          PASS=123456789 openssl pkcs12 -in certificates/ios_cert.p12 -nocerts -nodes -passin env:PASS || echo "Échec essai 3"
          
          # Importation manuelle avec openssl puis security
          echo "Importation avec OpenSSL"
          openssl pkcs12 -in certificates/ios_cert.p12 -nocerts -nodes -passin pass:123456789 | \
            security import /dev/stdin -k "$KEYCHAIN_PATH" -t priv -A -T /usr/bin/codesign || echo "Échec importation clé privée"
          
          openssl pkcs12 -in certificates/ios_cert.p12 -clcerts -nokeys -passin pass:123456789 | \
            security import /dev/stdin -k "$KEYCHAIN_PATH" -t cert -A -T /usr/bin/codesign || echo "Échec importation certificat"
          
          # Configurer les permissions
          security set-key-partition-list -S apple-tool:,apple: -s -k "temp_password" "$KEYCHAIN_PATH" || echo "Échec configuration permissions"
          
          # Vérifier l'installation
          echo "Liste des certificats installés dans le keychain:"
          security find-identity -p codesigning "$KEYCHAIN_PATH"

      - name: Vérifier que le certificat est installé
        run: |
          echo "Liste des certificats installés dans le trousseau temporaire:"
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          security find-identity -p codesigning "$KEYCHAIN_PATH"
          
          # Si aucun certificat n'est trouvé, afficher une erreur et arrêter le workflow
          if [[ $(security find-identity -p codesigning "$KEYCHAIN_PATH" | grep -c "valid identities found") == "0 valid identities found" ]]; then
            echo "❌ Aucun certificat valide n'a été trouvé. Arrêt du workflow."
            exit 1
          fi

      - name: Copier le profil de provisioning
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          cp certificates/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
          UUID=$(security cms -D -i certificates/profile.mobileprovision | plutil -extract UUID xml1 -o - - | plutil -p -)
          echo "UUID du profil: $UUID"
          # Renommer le profil avec son UUID pour assurer qu'Xcode le trouve
          cp certificates/profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/${UUID//\"/}.mobileprovision

      - name: Compiler l application iOS pour App Store
        run: |
          cd project
          flutter build ios --release --no-codesign
          
          # Afficher les infos sur le bundle Flutter généré
          ls -la build/ios/iphoneos

      - name: Préparer le projet Xcode avec les bons paramètres de signature
        run: |
          cd project/ios
          
          # Obtenir les identifiants nécessaires
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          SIGNING_IDENTITY=$(security find-identity -p codesigning "$KEYCHAIN_PATH" | grep "iPhone Distribution" | head -1 | sed -E 's/.*\) ([A-F0-9]+) "(.*)"/\1/')
          TEAM_ID="${{ secrets.TEAM_ID }}"
          APP_BUNDLE_ID="${{ secrets.APP_BUNDLE_ID }}"
          
          # Créer un script temporaire pour modifier la configuration de signature
          cat > update_project_settings.rb << 'EOL'
          require 'xcodeproj'
          
          # Ouvrir le projet principal
          project_path = 'Runner.xcodeproj'
          project = Xcodeproj::Project.open(project_path)
          
          # Configuration pour le target principal seulement (Runner)
          main_target = project.targets.find { |target| target.name == 'Runner' }
          
          if main_target
            main_target.build_configurations.each do |config|
              if config.name == 'Release'
                config.build_settings['CODE_SIGN_IDENTITY'] = 'iPhone Distribution'
                config.build_settings['DEVELOPMENT_TEAM'] = ENV['TEAM_ID']
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = ENV['PROVISIONING_PROFILE_NAME']
                config.build_settings['CODE_SIGN_STYLE'] = 'Manual'
              end
            end
          end
          
          # Désactiver la signature manuelle pour tous les pods
          pods_project_path = 'Pods/Pods.xcodeproj'
          if File.exist?(pods_project_path)
            pods_project = Xcodeproj::Project.open(pods_project_path)
            
            pods_project.targets.each do |target|
              target.build_configurations.each do |config|
                # Pour les pods, définir la signature en mode automatique
                config.build_settings['CODE_SIGN_STYLE'] = 'Automatic'
                config.build_settings['PROVISIONING_PROFILE_SPECIFIER'] = ''
                config.build_settings['CODE_SIGN_IDENTITY'] = ''
                
                # S'assurer que la version iOS minimale est à 12.0
                if config.build_settings['IPHONEOS_DEPLOYMENT_TARGET']
                  current_version = config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'].to_f
                  if current_version < 12.0
                    config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0'
                  end
                end
              end
            end
            
            pods_project.save
          end
          
          # Sauvegarder le projet principal
          project.save
          EOL
          
          # Exécuter le script Ruby pour modifier les projets
          TEAM_ID="$TEAM_ID" PROVISIONING_PROFILE_NAME="${{ secrets.PROVISIONING_PROFILE_NAME }}" \
          gem install xcodeproj
          ruby update_project_settings.rb

      - name: Créer ExportOptions.plist pour App Store
        run: |
          # Obtenir le UUID du profil de provisioning
          PROFILE_UUID=$(security cms -D -i certificates/profile.mobileprovision | plutil -extract UUID xml1 -o - - | plutil -p -)
          PROFILE_UUID=${PROFILE_UUID//\"/}
          
          cat <<EOF > project/ios/ExportOptions.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store</string>
              <key>signingStyle</key>
              <string>manual</string>
              <key>compileBitcode</key>
              <true/>
              <key>stripSwiftSymbols</key>
              <true/>
              <key>provisioningProfiles</key>
              <dict>
                  <key>${{ secrets.APP_BUNDLE_ID }}</key>
                  <string>${PROFILE_UUID}</string>
              </dict>
              <key>teamID</key>
              <string>${{ secrets.TEAM_ID }}</string>
              <key>destination</key>
              <string>export</string>
          </dict>
          </plist>
          EOF
          
          cat project/ios/ExportOptions.plist

      - name: Générer l IPA pour App Store avec Xcode
        run: |
          cd project/ios
          
          # Afficher l'identité de signature trouvée
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          SIGNING_IDENTITY=$(security find-identity -p codesigning "$KEYCHAIN_PATH" | grep "valid identities" -B 1 | head -1 | awk -F '"' '{print $2}')
          echo "Utilisation de l'identité de signature: $SIGNING_IDENTITY"
          
          xcodebuild -workspace Runner.xcworkspace \
            -scheme Runner \
            -sdk iphoneos \
            -configuration Release \
            CODE_SIGN_IDENTITY="$SIGNING_IDENTITY" \
            PROVISIONING_PROFILE_SPECIFIER="${{ secrets.PROVISIONING_PROFILE_NAME }}" \
            -allowProvisioningUpdates \
            archive -archivePath build/Runner.xcarchive
            
          xcodebuild -exportArchive \
            -archivePath build/Runner.xcarchive \
            -exportPath build/ios \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates

      # Nouvelles étapes pour la soumission à l'App Store
      - name: Installer Apple API Key
        run: |
          mkdir -p ~/.appstoreconnect/private_keys/
          echo "${{ secrets.APPSTORE_API_PRIVATE_KEY }}" > ~/.appstoreconnect/private_keys/AuthKey.p8
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey.p8

      - name: Soumettre IPA à App Store Connect
        env:
          APPLE_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APPLE_API_ISSUER_ID: ${{ secrets.APPSTORE_API_ISSUER_ID }}
        run: |
          # Obtenir le chemin de l'IPA généré
          IPA_PATH=$(find project/ios/build/ios -name "*.ipa" -type f | head -1)
          echo "Chemin de l'IPA: $IPA_PATH"
          
          # Installer les outils nécessaires
          gem install fastlane
          
          # Créer un Fastfile temporaire pour l'upload
          mkdir -p fastlane
          cat > fastlane/Fastfile << 'EOF'
          default_platform(:ios)
          
          platform :ios do
            desc "Soumettre à l'App Store"
            lane :upload do
              api_key = app_store_connect_api_key(
                key_id: ENV["APPLE_API_KEY_ID"],
                issuer_id: ENV["APPLE_API_ISSUER_ID"],
                key_filepath: "~/.appstoreconnect/private_keys/AuthKey.p8",
              )
              
              upload_to_app_store(
                api_key: api_key,
                ipa: ENV["IPA_PATH"],
                skip_screenshots: true,
                skip_metadata: true,
                precheck_include_in_app_purchases: false,
                force: true,
                submit_for_review: true
              )
            end
          end
          EOF
          
          # Exécuter fastlane pour l'upload
          IPA_PATH="$IPA_PATH" fastlane upload
          
      - name: Sauvegarder IPA en artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-appstore-ipa
          path: project/ios/build/ios/*.ipa
          compression-level: 0
